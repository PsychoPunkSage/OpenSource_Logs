# **Composite Templates**

## **Resouces**

>> In order to embed the template file into our application we take advantage of gio::Resource. The files to embed are again described by an `xml` file. For our template file we also add the `compressed` and `preprocess` attribute in order to reduce the final size of the resources.


`Filesystem`: ...../composite_templates/1/resources/resources.gresource.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<gresources>
  <gresource prefix="/org/gtk_rs/example/">
    <file compressed="true" preprocess="xml-stripblanks">window.ui</file>
  </gresource>
</gresources>
```

Now we have to compile the resources and link it to our application. One way to do this is to execute glib_build_tools::compile_resources within a cargo build script.

First, we have to add glib-build-tools as build dependency in Cargo.toml by executing:

```bash
cargo add glib-build-tools --build
```

Then, we create a `build.rs` at the root of our package with the following content. This will compile the resources whenever we trigger a build with cargo and then statically link our executable to them.

`Filesystem`: ...../build.rs

```rust
fn main() {
    glib_build_tools::compile_resources(
        &["composite_templates/1/resources"],
        "composite_templates/1/resources/resources.gresource.xml",
        "composite_templates_1.gresource",
    );
}
```

Finally, we register and include the resources by calling the macro `gio::resources_register_include!`. In your own apps take care to register the resources before creating the `gtk::Application`.

`Filesystem`: ...../composite_templates/1/main.rs

```rust
mod window;

use gtk::prelude::*;
use gtk::{gio, glib, Application};
use window::Window;

const APP_ID: &str = "org.gtk_rs.CompositeTemplates1";

fn main() -> glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("composite_templates_1.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}
fn build_ui(app: &Application) {
    // Create new window and present it
    let window = Window::new(app);
    window.present();
}
```

Within our code we create a custom widget inheriting from gtk::ApplicationWindow to make use of our template.