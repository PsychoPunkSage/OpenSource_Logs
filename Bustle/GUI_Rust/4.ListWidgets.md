# **List Widgets**

>>> Sometimes we want to display a list of elements in a certain arrangement. `gtk::ListBox` and `gtk::FlowBox` are two container widgets which allow you to do this. `ListBox` describes a vertical list and `FlowBox` describes a grid.

`Filesystem`: ...../list_widgets/1/main.rs

```rust
    // Create a `ListBox` and add labels with integers from 0 to 100
    let list_box = ListBox::new();
    for number in 0..=100 {
        let label = Label::new(Some(&number.to_string()));
        list_box.append(&label);
    }
```

We cannot display so many widgets at once. Therefore, we add `ListBox` to a `gtk::ScrolledWindow`. Now we can scroll through our elements.

`Filesystem`: ...../list_widgets/1/main.rs

```rust
    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&list_box)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .default_width(600)
        .default_height(300)
        .child(&scrolled_window)
        .build();

    // Present window
    window.present();
```

## **Views**

>> However, we currently create one widget per element. Since each widget takes up a bit of resources, many of them can lead to slow and unresponsive user interfaces. Depending on the widget type even thousands of elements might not be a problem.

We use scalable lists instead!

* The **model** holds our data, filters it and describes its order.
* The **list item factory** defines how the data transforms into widgets.
* The **view** specifies how the widgets are then arranged.

We start by defining and filling up our model. The model is an instance of `gio::ListStore`. The main limitation here is that `gio::ListStore` only accepts GObjects. So let's create a custom GObject `IntegerObject` that which is initialized with a number.

`Filesystem`: ...../list_widgets/2/integer_object/mod.rs

```rust
glib::wrapper! {
    pub struct IntegerObject(ObjectSubclass<imp::IntegerObject>);
}

impl IntegerObject {
    pub fn new(number: i32) -> Self {
        Object::builder().property("number", number).build()
    }
}
```

* This number represents the internal state of `IntegerObject`.

`Filesystem`: ...../list_widgets/2/integer_object/imp.rs

```rust
// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::IntegerObject)]
pub struct IntegerObject {
    #[property(get, set)]
    number: Cell<i32>,
}
```

We now fill the model with integers from 0 to 100 000. Please note that models only takes care of the data. Neither `Label` nor any other widget is mentioned here.

`Filesystem`: ...../list_widgets/2/main.rs

```rust
    // Create a `Vec<IntegerObject>` with numbers from 0 to 100_000
    let vector: Vec<IntegerObject> = (0..=100_000).map(IntegerObject::new).collect();

    // Create new model
    let model = gio::ListStore::new::<IntegerObject>();

    // Add the vector to the model
    model.extend_from_slice(&vector);
```

The `ListItemFactory` takes care of the widgets as well as their relationship to the model. Here, we use the `SignalListItemFactory` which emits a signal for every relevant step in the life of a `ListItem`. The "setup" signal will be emitted when new widgets have to be created. We connect to it to create a `Label` for every requested widget.