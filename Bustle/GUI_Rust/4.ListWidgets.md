# **List Widgets**

>>> Sometimes we want to display a list of elements in a certain arrangement. `gtk::ListBox` and `gtk::FlowBox` are two container widgets which allow you to do this. `ListBox` describes a vertical list and `FlowBox` describes a grid.

`Filesystem`: ...../list_widgets/1/main.rs

```rust
    // Create a `ListBox` and add labels with integers from 0 to 100
    let list_box = ListBox::new();
    for number in 0..=100 {
        let label = Label::new(Some(&number.to_string()));
        list_box.append(&label);
    }
```

We cannot display so many widgets at once. Therefore, we add `ListBox` to a `gtk::ScrolledWindow`. Now we can scroll through our elements.

`Filesystem`: ...../list_widgets/1/main.rs

```rust
    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&list_box)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .default_width(600)
        .default_height(300)
        .child(&scrolled_window)
        .build();

    // Present window
    window.present();
```

## **Views**

>> However, we currently create one widget per element. Since each widget takes up a bit of resources, many of them can lead to slow and unresponsive user interfaces. Depending on the widget type even thousands of elements might not be a problem.

We use scalable lists instead!

* The **model** holds our data, filters it and describes its order.
* The **list item factory** defines how the data transforms into widgets.
* The **view** specifies how the widgets are then arranged.